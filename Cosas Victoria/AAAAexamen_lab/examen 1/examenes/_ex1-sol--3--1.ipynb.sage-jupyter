{"kernelspec":{"display_name":"SageMath 7.3","language":"","name":"sagemath"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{},"source":"<p><span style=\"color: #ff0000;\">Por favor, antes de empezar el examen cambia el nombre de la hoja (File&gt;Rename worksheet) poniendo en lugar de \"nombre.apellido\" los tuyos tal como aparecen en tu direcci&oacute;n de correo electr&oacute;nico de la UAM. El final del nombre de la hoja, -labot-ex1, dej&aacute;lo como est&aacute;.<br /></span></p>\n<p><span style=\"color: #ff0000;\">Una vez hayas terminado el examen, salva la hoja (File&gt;Save worksheet to a file....) y d&eacute;jala en la carpeta en tu escritorio con nombre \"ENTREGA......\".</span></p>\n<h4>&nbsp;</h4>\n<h4>&nbsp;</h4>\n<h4>Ejercicio1</h4>\n<p>Decimos que un entero positivo $n$ es <strong>multiplicativamente perfecto</strong> si el producto de todos los divisores de $n$ vale exactamente $n^2.$ El ejemplo m&aacute;s sencillo de un n&uacute;mero multiplicativamente perfecto es el producto $n=p\\cdot q$ de dos primos distintos. Por tanto, existen infinitos enteros multiplicativamente perfectos. Queremos caracterizar los enteros multiplicativamente perfectos.</p>\n<ol>\n<li>Primero define una funci&oacute;n de Sage, de nombre $perfecto(n)$,&nbsp; que reciba como argumento un entero $n$ y devuelva $Truo$ o $False$ seg&uacute;n el n&uacute;mero $n$ sea multiplicativamente perfecto o no.</li>\n<li>Ahora define una funci&oacute;n de Sage, de nombre $perfectos(N)$,&nbsp; que reciba como argumento un entero $N$ y devuelva la lista de todos los enteros multiplicativamente perfectos que pertenecen al intervalo $[1,N].$</li>\n<li>Usando las listas de enteros multiplicativamente perfectos que puedes obtener con la funci&oacute;n del apartado anterior, produce una conjetura razonable acerca de qu&eacute; enteros son multiplicativamente perfectos. Debes escribir expl&iacute;citamente tu conjetura en una celda de texto.</li>\n<li>Define una tercera funci&oacute;n, de nombre $comprobar(N)$, que devuelva $True$ si tu conjetura es correcta para enteros positivos menores que $N$, y $False$ si no lo es.</li>\n<li>Experimenta con valores de $N$ suficientemente grandes para obtener&nbsp; el $N=10^t$ ($t$ entero) m&aacute;s grande tal que tu programa $comprobar(N)$ se ejecuta en menos de un minuto.</li>\n</ol>"}
{"cell_type":"code","execution_count":57,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def comprobar(N):\n    M=[]\n    for n in xsrange(1,N+1):\n        if perfecto(n):\n            #print (factor(n))\n            L = list(factor(n))\n            #print L\n            if ((len(L)>2) or (len(L)==2 and (L[0][1]>1 or L[1][1]>1)) or (len(L)==1 and L[0][1] != 3)) :\n                M.append(false)\n            else:\n                M.append(true)\n    return M"}
{"cell_type":"code","execution_count":58,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"ename":"NameError","evalue":"global name 'perfecto' is not defined","output_type":"error","traceback":["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m","\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)","\u001b[1;32m<ipython-input-58-8b57590014eb>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mall\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mcomprobar\u001b[0m \u001b[1;33m(\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m7\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[1;32m<ipython-input-57-d8ce127ab23a>\u001b[0m in \u001b[0;36mcomprobar\u001b[1;34m(N)\u001b[0m\n\u001b[0;32m      2\u001b[0m     \u001b[0mM\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      3\u001b[0m     \u001b[1;32mfor\u001b[0m \u001b[0mn\u001b[0m \u001b[1;32min\u001b[0m \u001b[0mxsrange\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mN\u001b[0m\u001b[1;33m+\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 4\u001b[1;33m         \u001b[1;32mif\u001b[0m \u001b[0mperfecto\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mn\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      5\u001b[0m             \u001b[1;31m#print (factor(n))\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      6\u001b[0m             \u001b[0mL\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mlist\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mfactor\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mn\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;31mNameError\u001b[0m: global name 'perfecto' is not defined"]}],"source":"all(comprobar (7))"}
{"cell_type":"code","execution_count":50,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/plain":"True"},"execution_count":50,"metadata":{},"output_type":"execute_result"}],"source":"all(comprobar(10^1))"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"all(comprobar(10^3))"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def perfecto(n):\n    if prod(divisors(n))==n^2:\n        return true\n    else:\n        return false"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"perfecto(8)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"perfecto(7)"}
{"cell_type":"code","execution_count":30,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def perfectos(N):\n    L=[] \n    for n in srange(1, N+1):\n        if(perfecto(n)):\n            L.append(n)\n    return L"}
{"cell_type":"code","execution_count":38,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left[1, 6, 8, 10, 14, 15, 21, 22, 26, 27, 33, 34, 35, 38, 39, 46, 51, 55, 57, 58, 62, 65, 69, 74, 77, 82, 85, 86, 87, 91, 93, 94, 95\\right]</script></html>","text/plain":"[1,\n 6,\n 8,\n 10,\n 14,\n 15,\n 21,\n 22,\n 26,\n 27,\n 33,\n 34,\n 35,\n 38,\n 39,\n 46,\n 51,\n 55,\n 57,\n 58,\n 62,\n 65,\n 69,\n 74,\n 77,\n 82,\n 85,\n 86,\n 87,\n 91,\n 93,\n 94,\n 95]"},"metadata":{},"output_type":"display_data"}],"source":"show(perfectos(100))"}
{"cell_type":"code","execution_count":42,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left[1, 2 \\cdot 3, 2^{3}, 2 \\cdot 5, 2 \\cdot 7, 3 \\cdot 5, 3 \\cdot 7, 2 \\cdot 11, 2 \\cdot 13, 3^{3}, 3 \\cdot 11, 2 \\cdot 17, 5 \\cdot 7, 2 \\cdot 19, 3 \\cdot 13, 2 \\cdot 23, 3 \\cdot 17, 5 \\cdot 11, 3 \\cdot 19, 2 \\cdot 29, 2 \\cdot 31, 5 \\cdot 13, 3 \\cdot 23, 2 \\cdot 37, 7 \\cdot 11, 2 \\cdot 41, 5 \\cdot 17, 2 \\cdot 43, 3 \\cdot 29, 7 \\cdot 13, 3 \\cdot 31, 2 \\cdot 47, 5 \\cdot 19\\right]</script></html>","text/plain":"[1,\n 2 * 3,\n 2^3,\n 2 * 5,\n 2 * 7,\n 3 * 5,\n 3 * 7,\n 2 * 11,\n 2 * 13,\n 3^3,\n 3 * 11,\n 2 * 17,\n 5 * 7,\n 2 * 19,\n 3 * 13,\n 2 * 23,\n 3 * 17,\n 5 * 11,\n 3 * 19,\n 2 * 29,\n 2 * 31,\n 5 * 13,\n 3 * 23,\n 2 * 37,\n 7 * 11,\n 2 * 41,\n 5 * 17,\n 2 * 43,\n 3 * 29,\n 7 * 13,\n 3 * 31,\n 2 * 47,\n 5 * 19]"},"metadata":{},"output_type":"display_data"}],"source":"show(map(factor, perfectos(100)))"}
{"cell_type":"markdown","metadata":{},"source":"<p>Vemos que todos los enteros multiplicativamente perfectos en este rango son producto de dos primos distintos o cubos de primos.&nbsp; Es&nbsp; claro que los productos de dos primos y los cubos de primos son multiplicativamente perfectos, pero &iquest;son los &uacute;nicos?</p>"}
{"cell_type":"markdown","metadata":{},"source":"<h4>Ejercicio 2</h4>\n<p>En este ejercicio queremos definir funciones para comparar listas de enteros, <strong>salvo el orden de sus elementos</strong>,&nbsp; es decir, diremos que dos listas son <strong>casi-iguales</strong> si tienen la misma longitud y los mismos elementos pero no necesariamente en los mismos lugares. Las funciones que vamos a definir son 'tests' de casi-igualdad de listas.</p>\n<ol>\n<li>Primer m&eacute;todo: despu&eacute;s de comparar longitudes, y devolver $False$ si son diferentes, recorrer los elementos de la primera lista comprobando si son elementos de la segunda tambi&eacute;n. Si encontramos un elemento que est&aacute; en la primera lista y no en la segunda es claro que debemos devolver $False$, pero cada vez que encontramos un elemento que est&aacute; en las dos listas &iquest;qu&eacute; debemos hacer? Completa la idea para este m&eacute;todo y&nbsp; define una funci&oacute;n de Sage que lo implemente.</li>\n<li>Segundo m&eacute;todo:&nbsp; despu&eacute;s de comparar longitudes, y devolver $False$ si son diferentes, ordena las dos listas (puedes usar el m&eacute;todo $sort$ de Sage). Ahora compara las listas ordenadas&nbsp; recorriendo los elementos de la primera y comprobando si es igual al que ocupa el mismo lugar en la segunda.&nbsp; Define una funci&oacute;n de Sage que implemente este m&eacute;todo.</li>\n</ol>\n<p>Compara la eficiencia de los dos m&eacute;todos y discute los resultados obtenidos. Debes tener en cuenta que los tiempos obtenidos depender&aacute;n mucho de lo diferentes que sean las listas y debemos esperar que se obtengan tiempos mayores, y es el caso que nos conviene analizar,&nbsp; cuando una de las listas sea una reordenaci&oacute;n de la otra.&nbsp; Para producir una reordenaci&oacute;n aleatoria de una lista $L$ se pueden ejecutar las siguientes&nbsp; instrucciones en una celda</p>\n<p>$import \\ \\ numpy\\ \\&nbsp; as\\&nbsp; \\ np$</p>\n<p>$L1 = np.random.permutation(L).tolist()$</p>\n<p>y queda definida la lista $L1$ que es una permutaci&oacute;n aleatoria&nbsp; de la lista $L$.</p>"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def test(L1, L2):\n    L3= list(L2)\n    if(len(L1)==len(L3)):\n        for i in srange(0, len(L1)):\n            for j in srange(0, len(L1)):\n                if(L1[i]==L3[j]):\n                    L3.remove(L3[j])        \n        if(len(L3)==0):\n            return true\n    return false"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"L1=(0,1,2)\nL2=(0,1,2)\ntest(L1, L2)"}
{"cell_type":"markdown","metadata":{},"source":"<h4>Ejercicio 3</h4>\n<p>En este ejercicio estudiamos la existencia de ra&iacute;ces $k$-&eacute;simas en el anillo $\\mathbb{Z}_m$ de clases de restos m&oacute;dulo un entero $m$ . Como es natural,&nbsp; dados elementos&nbsp; $a,b\\in &nbsp; \\mathbb{Z}_m$, decimos que $a$ es una ra&iacute;z $k$-&eacute;sima de $b$ si $a^k=b$ en $\\mathbb{Z}_m$. Nuestro objetivo es, dado el entero $m$,&nbsp; determinar los valores de $k&lt;m$ tales que todos los elementos de $\\mathbb{Z}_m$ tienen una ra&iacute;z $k$-&eacute;sima.</p>\n<ol>\n<li>Define una funci&oacute;n de Sage, con nombre $raices(m,k)$, que devuelva $True$ si todas las clases de restos m&oacute;dulo $m$ tienen una ra&iacute;z $k$-&eacute;sima , con $k&lt;m$, y $False$ en caso contrario.</li>\n<li>Aplica la funci&oacute;n $raices(m,k)$ con $m$ primo, por ejemplo $m=23$, $m=31$, y trata de entender (explicita una conjetura) cu&aacute;les son los valores de $k$ para los que se obtiene $True$.&nbsp; Define una nueva funci&oacute;n de Sage, $comprobador(N)$&nbsp; que sirva para comprobar si&nbsp; tu conjetura es cierta para todos los enteros primos&nbsp; del intervalo $[1,N].$ Mediante esta funci&oacute;n comprueba tu conjetura hasta el $N=10^t$ ($t$ entero) m&aacute;s grande tal que la comprobaci&oacute;n tarde menos de un minuto.</li>\n<li>&nbsp;Si todav&iacute;a tienes tiempo y ganas puedes estudiar el caso de enteros $m$ que son producto de dos primos distintos.</li>\n</ol>"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}