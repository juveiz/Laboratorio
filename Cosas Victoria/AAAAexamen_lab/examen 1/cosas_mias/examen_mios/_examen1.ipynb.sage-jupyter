{"kernelspec":{"display_name":"SageMath 7.3","language":"","name":"sagemath"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.10"}}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"<p><span style=\"color: #ff0000;\">Por favor, antes de empezar el examen cambia el nombre de la hoja (File&gt;Rename worksheet) poniendo en lugar de \"nombre.apellido\" los tuyos tal como aparecen en tu direcci&oacute;n de correo electr&oacute;nico de la UAM. El final del nombre de la hoja, -labot-ex1, dej&aacute;lo como est&aacute;.<br /></span></p>\n<p><span style=\"color: #ff0000;\">Una vez hayas terminado el examen, salva la hoja (File&gt;Save worksheet to a file....) y d&eacute;jala en la carpeta en tu escritorio con nombre \"ENTREGA......\".</span></p>\n<h4>&nbsp;</h4>\n<h4>Ejercicio1</h4>\n<p>Decimos que un entero positivo $n$ es <strong>multiplicativamente perfecto</strong> si el producto de todos los divisores de $n$ vale exactamente $n^2.$ El ejemplo m&aacute;s sencillo de un n&uacute;mero multiplicativamente perfecto es el producto $n=p\\cdot q$ de dos primos distintos. Por tanto, existen infinitos enteros multiplicativamente perfectos. Queremos caracterizar los enteros multiplicativamente perfectos.</p>\n<ol>\n<li>Primero define una funci&oacute;n de Sage, de nombre $perfecto(n)$,&nbsp; que reciba como argumento un entero $n$ y devuelva $Truo$ o $False$ seg&uacute;n el n&uacute;mero $n$ sea multiplicativamente perfecto o no.</li>\n<li>Ahora define una funci&oacute;n de Sage, de nombre $perfectos(N)$,&nbsp; que reciba como argumento un entero $N$ y devuelva la lista de todos los enteros multiplicativamente perfectos que pertenecen al intervalo $[1,N].$</li>\n<li>Usando las listas de enteros multiplicativamente perfectos que puedes obtener con la funci&oacute;n del apartado anterior, produce una conjetura razonable acerca de qu&eacute; enteros son multiplicativamente perfectos. Debes escribir expl&iacute;citamente tu conjetura en una celda de texto.</li>\n<li>Define una tercera funci&oacute;n, de nombre $comprobar(N)$, que devuelva $True$ si tu conjetura es correcta para enteros positivos menores que $N$, y $False$ si no lo es.</li>\n<li>Experimenta con valores de $N$ suficientemente grandes para obtener&nbsp; el $N=10^t$ ($t$ entero) m&aacute;s grande tal que tu programa $comprobar(N)$ se ejecuta en menos de un minuto.</li>\n</ol>"}
{"cell_type":"code","execution_count":19,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def perfecto(n):\n    if prod(divisors(n))==n^2:\n        return true\n    else:\n        return false"}
{"cell_type":"code","execution_count":63,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def print_sol(n):\n    print divisors(n)\n    print prod(divisors(n))\n    print n^2\n    print perfecto(n)\n"}
{"cell_type":"code","execution_count":64,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"[1, 2, 5, 10]\n100\n100\nTrue\n"}],"source":"print_sol(10)"}
{"cell_type":"code","execution_count":31,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def perfectos(n):\n    L=[]\n    for i in range (1, n+1):\n        if (perfecto(i)):\n            L.append(i)\n    return L"}
{"cell_type":"code","execution_count":39,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"data":{"text/html":"<html><script type=\"math/tex; mode=display\">\\newcommand{\\Bold}[1]{\\mathbf{#1}}\\left[1, 6, 8, 10, 14, 15, 21, 22, 26, 27, 33, 34, 35, 38, 39, 46\\right]</script></html>","text/plain":"[1, 6, 8, 10, 14, 15, 21, 22, 26, 27, 33, 34, 35, 38, 39, 46]"},"metadata":{},"output_type":"display_data"}],"source":"#tomamos N=100\nL=(perfectos(50))\nshow (L)"}
{"cell_type":"code","execution_count":40,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"[1, 2 * 3, 2^3, 2 * 5, 2 * 7, 3 * 5, 3 * 7, 2 * 11, 2 * 13, 3^3, 3 * 11, 2 * 17, 5 * 7, 2 * 19, 3 * 13, 2 * 23]\n"}],"source":"L2=map(factor,L)\nprint L2"}
{"cell_type":"markdown","metadata":{},"source":"Observamos que los multiplicativamente perfectos son producto de 2 numeros primos o el cubo de un primo, pero tenemos que comporobarlo."}
{"cell_type":"code","execution_count":100,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"#Define una tercera función, de nombre  comprobar(N), que devuelva  True  si tu conjetura es correcta para enteros \n#positivos menores que  NN , y  False  si no lo es.\ndef comprobar(N):\n    for i in range (1,N):\n        if (perfecto(i)):\n            L3=list(factor(N))\n            if ((len(L)>2) or (len(L)==2 and (L[0][1]>1 or L[1][1]>1)) or (len(L)==1 and L[0][1] != 3)) :\n                L.append(false)\n    print L3\n    return \"Conjetura correcta hasta N\""}
{"cell_type":"code","execution_count":101,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"[(2, 2), (5, 2)]\n"},{"data":{"text/plain":"'Conjetura correcta hasta N'"},"execution_count":101,"metadata":{},"output_type":"execute_result"}],"source":"comprobar (100)"}
{"cell_type":"code","execution_count":61,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"len?"}
{"cell_type":"markdown","metadata":{},"source":"<h4>Ejercicio 2</h4>\n<p>En este ejercicio queremos definir funciones para comparar listas de enteros, <strong>salvo el orden de sus elementos</strong>,&nbsp; es decir, diremos que dos listas son <strong>casi-iguales</strong> si tienen la misma longitud y los mismos elementos pero no necesariamente en los mismos lugares. Las funciones que vamos a definir son 'tests' de casi-igualdad de listas.</p>\n<ol>\n<li>Primer m&eacute;todo: despu&eacute;s de comparar longitudes, y devolver $False$ si son diferentes, recorrer los elementos de la primera lista comprobando si son elementos de la segunda tambi&eacute;n. Si encontramos un elemento que est&aacute; en la primera lista y no en la segunda es claro que debemos devolver $False$, pero cada vez que encontramos un elemento que est&aacute; en las dos listas &iquest;qu&eacute; debemos hacer? Completa la idea para este m&eacute;todo y&nbsp; define una funci&oacute;n de Sage que lo implemente.</li>\n<li>Segundo m&eacute;todo:&nbsp; despu&eacute;s de comparar longitudes, y devolver $False$ si son diferentes, ordena las dos listas (puedes usar el m&eacute;todo $sort$ de Sage). Ahora compara las listas ordenadas&nbsp; recorriendo los elementos de la primera y comprobando si es igual al que ocupa el mismo lugar en la segunda.&nbsp; Define una funci&oacute;n de Sage que implemente este m&eacute;todo.</li>\n</ol>\n<p>Compara la eficiencia de los dos m&eacute;todos y discute los resultados obtenidos. Debes tener en cuenta que los tiempos obtenidos depender&aacute;n mucho de lo diferentes que sean las listas y debemos esperar que se obtengan tiempos mayores, y es el caso que nos conviene analizar,&nbsp; cuando una de las listas sea una reordenaci&oacute;n de la otra.&nbsp; Para producir una reordenaci&oacute;n aleatoria de una lista $L$ se pueden ejecutar las siguientes&nbsp; instrucciones en una celda</p>\n<p>$import \\ \\ numpy\\ \\&nbsp; as\\&nbsp; \\ np$</p>\n<p>$L1 = np.random.permutation(L).tolist()$</p>\n<p>y queda definida la lista $L1$ que es una permutaci&oacute;n aleatoria&nbsp; de la lista $L$.</p>"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":" def comparacion_longitud(L1, L2):\n        print \"¿Tienen la misma longitud?\"\n        if (len(L1)==len(L2)):\n            print true\n            return true\n        else:\n            print false\n            return false"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"L1=(3,3,3)\nL2=(3,1,2)\ncomparacion_longitud(L1, L2)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def comparacion_listas(L1,L2):\n    #hacemos una copia para no modifificar las tablas originales\n    L1.sort()\n    L2.sort()\n    if (comparacion_longitud(L1,L2)==false):\n        return false\n    for i in sxrange(1,len(L1)):\n        if(L1[i]==L2[i]):\n            return true\n        else:\n            return false"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"comparacion_listas(L1,L2)"}
{"cell_type":"code","execution_count":134,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"ename":"TypeError","evalue":"unsupported operand parent(s) for '-': '<type 'list'>' and 'Integer Ring'","output_type":"error","traceback":["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m","\u001b[1;31mTypeError\u001b[0m                                 Traceback (most recent call last)","\u001b[1;32m<ipython-input-134-637e864f8e83>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[0;32m      1\u001b[0m \u001b[0mA\u001b[0m\u001b[1;33m=\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m4\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m5\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m6\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 2\u001b[1;33m \u001b[0mB\u001b[0m\u001b[1;33m=\u001b[0m\u001b[0mA\u001b[0m\u001b[1;33m-\u001b[0m\u001b[0mA\u001b[0m\u001b[1;33m[\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m2\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m]\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      3\u001b[0m \u001b[1;32mprint\u001b[0m \u001b[0mB\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;32m/projects/sage/sage-7.3/src/sage/rings/integer.pyx\u001b[0m in \u001b[0;36msage.rings.integer.Integer.__sub__ (/projects/sage/sage-7.3/src/build/cythonized/sage/rings/integer.c:11451)\u001b[1;34m()\u001b[0m\n\u001b[0;32m   1677\u001b[0m             \u001b[1;32mreturn\u001b[0m \u001b[0my\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1678\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1679\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0mcoercion_model\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mbin_op\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mleft\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mright\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0moperator\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0msub\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1680\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1681\u001b[0m     \u001b[0mcpdef\u001b[0m \u001b[0m_sub_\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mright\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;32m/projects/sage/sage-7.3/src/sage/structure/coerce.pyx\u001b[0m in \u001b[0;36msage.structure.coerce.CoercionModel_cache_maps.bin_op (/projects/sage/sage-7.3/src/build/cythonized/sage/structure/coerce.c:9974)\u001b[1;34m()\u001b[0m\n\u001b[0;32m   1089\u001b[0m         \u001b[1;31m# We should really include the underlying error.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1090\u001b[0m         \u001b[1;31m# This causes so much headache.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1091\u001b[1;33m         \u001b[1;32mraise\u001b[0m \u001b[0mTypeError\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0marith_error_message\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mx\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0my\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mop\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1092\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1093\u001b[0m     \u001b[0mcpdef\u001b[0m \u001b[0mcanonical_coercion\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mself\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mx\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0my\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;31mTypeError\u001b[0m: unsupported operand parent(s) for '-': '<type 'list'>' and 'Integer Ring'"]}],"source":"A=[4,5,6]\nB=A-A[2]\nprint B"}
{"cell_type":"code","execution_count":136,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"Object `count` not found.\n"}],"source":".count?"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":".count"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":""}