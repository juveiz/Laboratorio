{"kernelspec":{"display_name":"SageMath 7.5","language":"","name":"sagemath"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.13"}}
{"cell_type":"markdown","metadata":{},"source":"1) Antes que nada, lee cuidadosamente estas instrucciones y las que aparecen en la hoja con la contraseña. .\n\n2) Cambia el nombre de este archivo sustituyendo \"nombre.apellido\" por los tuyos, tal como aparecen en tu dirección de correo electrónico de la UAM.\n\n3) Este archivo debe quedar en la carpeta \"ENTREGA...\" que está en el escritorio de tu cuenta de examen. Lo mejor es que esté en esa carpeta desde el comienzo del examen.\n\n4) Recuerda que hay que deshabilitar el salvapantallas al comenzar el examen, tal como está indicado en la hoja con la contraseña. \n\n\nCALIFICACIÓN:\n"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":""}
{"cell_type":"markdown","metadata":{},"source":"En este examen los tres ejercicios están relacionados, de una forma u otra,  con el *cálculo de factoriales de enteros*. Debe sorprendernos, al menos un poco,  que sea posible calcular estos enteros enormes en tan poco tiempo, y  el tercer ejercicio empieza a indicar cómo podemos mejorar la simple multiplicación de los enteros entre $1$ y $n$.  "}
{"cell_type":"markdown","metadata":{},"source":"## Ejercicio 1 (4 puntos)\n\nLa congruencia de Wilson afirma que para todo número primo $p$ se verifica que el factorial de $p-1$ es congruente con $-1$ módulo $p$. Es interesante que el recíproco también es cierto: si un entero $n$ verifica la congruencia de Wilson entonces es primo, y por tanto la congruencia de Wilson puede servir como un criterio de primalidad.\n\nEl método más simple, pero no el más eficiente,  para determinar si un número $n$ es primo es la criba de Eratóstenes, es decir,  $n$ es primo si después de cribar la lista de enteros entre $2$ y $n$, ambos inclusive, $n$ está todavía en la lista cribada. Vimos en clase dos formas de implementar la criba, la segunda,  mucho más eficiente que la primera, se reproduce en la siguiente celda. \n\n**En este ejercicio debes comparar, en términos de eficiencia,  la criba con el criterio de Wilson como método para decidir si un entero $n$ es primo, es decir, debes producir  evidencia que demuestre, suficientemente, cuál de los dos métodos es mejor. No olvides discutir las consecuencias que obtienes del experimento.**\n\nPara medir tiempos puedes usar la función de SAGE $cputime()$, y con los tiempos obtenidos debes generar gráficas que permitan **ver** la diferencia entre los métodos.\n\nEl número de enteros $n$ para los que medimos los tiempos  no puede ser muy grande, por ejemplo deberíamos conformarnos con unos $100$ enteros, pero los enteros $n$ habría que seleccionarlos, usando la función de SAGE $randint(N1,N2)$,  en rangos $[N1,N2]$ suficientemente grandes. Por ejemplo, puedes usar $[10^4,10^5]$ y también $[10^5,10^6]$. Los parámetros sugeridos son sólo una indicación, y puede ser necesario modificarlos, pero si se aumenta el rango, por ejemplo hasta $10^7$, sería conveniente disminuir el número de enteros para los que medimos los tiempos. \n\n**¿Qué buscamos con este experimento? Es muy posible que en cierto rango $[N1,N2]$ uno de los métodos sea sistemáticamente mejor y en otro rango lo sea el otro. Querríamos identificar aproximadamente dónde se produce, si es que se produce,  el cambio.**"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def criba(n):\n        '''n al menos 2'''\n        aux = [True]*int(n)\n        aux[0] = False\n        aux[1] = False\n        for i in xrange(2,floor(sqrt(n))+1):\n            if aux[i]:\n                for j in xrange(i*i,n,i):\n                    aux[j] = False\n        return [k for k in xrange(n) if aux[k]==True]"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def primo_criba(n):\n    L = criba(n+1)\n    if L[-1]==n:\n        return True\n    else:\n        return False"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def wilson(n):\n    if (factorial(n-1)+1)%n == 0:\n        return True\n    else:\n        return False"}
{"cell_type":"markdown","metadata":{},"source":"Compruebo que las dos funciones producen el mismo resultado."}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"True"},"execution_count":4,"metadata":{},"output_type":"execute_result"}],"source":"all([primo_criba(n)==wilson(n) for n in xsrange(2,100)])"}
{"cell_type":"code","execution_count":5,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"def grafica_dif_tiempos(N,K1,K2):\n    L = []\n    for _ in xsrange(N):\n        n = randint(K1,K2)\n        tcpu0 = cputime()\n        primo_criba(n)\n        t1 = cputime()-tcpu0\n        tcpu0 = cputime()\n        wilson(n)\n        t2 = cputime()-tcpu0\n        L.append((n,1000*(t2-t1)))\n    L.sort()\n    return L"}
{"cell_type":"code","execution_count":6,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"L1 = grafica_dif_tiempos(10**2,10**4,10**5)"}
{"cell_type":"code","execution_count":7,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::3e187fb2-8e91-48ec-90a9-64ebce3c9d09","text/plain":"Graphics object consisting of 1 graphics primitive"},"execution_count":7,"metadata":{},"output_type":"execute_result"}],"source":"line(L1)"}
{"cell_type":"code","execution_count":11,"metadata":{"collapsed":false,"trusted":false},"outputs":[],"source":"L2 = grafica_dif_tiempos(10**2,10**5,10**6)"}
{"cell_type":"code","execution_count":12,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::3730012a-b1af-4456-b98f-218a14d998c9","text/plain":"Graphics object consisting of 1 graphics primitive"},"execution_count":12,"metadata":{},"output_type":"execute_result"}],"source":"line(L2)"}
{"cell_type":"markdown","metadata":{},"source":"Parece claro que para enteros $n$ relativamente pequeños, en $L1$ entre $10^4$ y $10^5$, el método de Wilson es casi siempre mejor que la criba. Esto puede deberse a que el cálculo del factorial es, en este rango, muy rápido. En $L2$ tomamos los enteros entre $10^5$ y $10^6$ y la tendencia se invierte, siendo mucho peor el método que usa Wilson que la simple criba. Estos resultados pueden depender del *hardware*, es decir, se comprueba que el mismo código produce resultados significativamente diferentes en distintas máquinas.\n\nEntonces, si vuelves a ejecutar estas celdas, en una máquina diferente, el párrafo anterior puede perder su sentido. "}
{"cell_type":"markdown","metadata":{},"source":"## Ejercicio 2 (3 puntos)\n\nEn este ejercicio **estudiamos diversos métodos para calcular el número binomial $\\binom{n}{m}$**, que,  por definición,  es el entero $$\\binom{n}{m}:=\\frac{n!}{m!(n-m)!},$$ y cuenta el número de subconjuntos con $m$ elementos de un conjunto de $n$ elementos. \n\n1) Un primer método,  que usaremos como base para nuestras comparaciones, consiste en usar la definición anterior\ndirectamente, es decir, calculando los factoriales y realizando las operaciones indicadas. Define una función de SAGE de nombre $binomial\\_1(n,m)$ y que devuelva el factorial calculado de esta manera. \n\n2) El cálculo anterior se puede organizar mejor: simplificamos $(n-m)!$ con parte de $n!$ y utilizamos que queda el mismo número de factores en el numerador que en el denominador para calcular el binomial más eficientemente. Define una función de SAGE de nombre $binomial\\_2(n,m)$ y que devuelva el factorial calculado de esta manera. \n\n3) Otra manera de calcular el binomial es la base del *triángulo de Tartaglia*, es decir, las relaciones \n$$\\binom{n}{0}=\\binom{n}{n}=1;\\binom{n}{m}=\\binom{n-1}{m-1}+\\binom{n-1}{m},$$\nque permitirían una definición recursiva del binomial. NO se pide esta solución recursiva, que no sería nada eficiente,  sino una iterativa equivalente. Define una función de SAGE de nombre $binomial\\_3(n,m)$ que utilice bucles y las relaciones anteriores para calcular el binomial. En cierto sentido este programa haría  lo mismo que cuando calculamos el triángulo de Tartaglia a mano. \n\n4) **Ejecuta las celdas incluidas al final de este ejercicio para comprobar que las funciones son correctas. ¿Algún comentario acerca de estos resultados?**"}
{"cell_type":"code","execution_count":50,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def binomial_1(n,m):\n    return factorial(n)/(factorial(m)*factorial(n-m))"}
{"cell_type":"code","execution_count":51,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def binomial_2(n,m):\n    prod = 1\n    for i in xsrange(1,m+1):\n        prod *= (n+1-i)/i\n    return prod"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def binomial_2b(n,m):\n    if m < n-m:\n        prod = 1\n        for i in xsrange(1,m+1):\n            prod *= (n+1-i)/i\n        return prod\n    else:\n        return binomial_2b(n,n-m)"}
{"cell_type":"code","execution_count":13,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def binomial_3(n,m):\n    '''Tartaglia'''\n    parc = [1,1]\n    for N in xsrange(1,n):\n        parc2 = [1]*(N+1)\n        for N2 in xsrange(1,N):\n            parc2[N2]= parc[N2-1]+parc[N2]\n        parc = parc2\n        del parc2\n    return parc[m-1]+parc[m]"}
{"cell_type":"code","execution_count":12,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 0 ns, sys: 0 ns, total: 0 ns\nWall time: 951 µs\n"}],"source":"%time N = binomial(12456,652) ##Binomial de SAGE"}
{"cell_type":"code","execution_count":63,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 4 ms, sys: 0 ns, total: 4 ms\nWall time: 4.22 ms\n"},{"data":{"text/plain":"True"},"execution_count":63,"metadata":{},"output_type":"execute_result"}],"source":"%time N == binomial_1(12456,652)"}
{"cell_type":"code","execution_count":64,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 4 ms, sys: 0 ns, total: 4 ms\nWall time: 1.69 ms\n"},{"data":{"text/plain":"True"},"execution_count":64,"metadata":{},"output_type":"execute_result"}],"source":"%time N == binomial_2(12456,652)"}
{"cell_type":"code","execution_count":14,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 1min 10s, sys: 500 ms, total: 1min 10s\nWall time: 1min 10s\n"},{"data":{"text/plain":"True"},"execution_count":14,"metadata":{},"output_type":"execute_result"}],"source":"%time N == binomial_3(12456,652)"}
{"cell_type":"markdown","metadata":{},"source":"1) En $binomial\\_2b(n,m)$ se tiene en cuenta que $\\binom{n}{m}=\\binom{n}{n-m}$ para calcular el binomial que menos multiplicaciones requiera. \n\n2) Parece que la segunda forma de calcular el binomial es bastante mejor que la primera, al menos en ciertos rangos. Por una parte la definición del factorial de SAGE está muy optimizada, es decir debemos esperar que el número de multiplicaciones qiue realiza es el mínimo posible, pero sin calcular factoriales podemos calcular el binomial  con *pocos* productos de números racionales, y dependemos de la eficiencia de las simplificaciones de racionales que realiza SAGE. \n\n3) El método del *triángulo de Tartaglia* no parece muy eficiente, aunque sólo realiza sumas. Quizá se puede mejorar calculando en cada fila del triángulo únicamente los elementos cuyo valor influye en el binomial que estamos calculando. Por ejemplo,  para calcular $\\binom{n}{m}$ sólo necesitamos de la fila anterior dos elementos. Para hacer esto dibuja en un triángulo de Tartaglia la zona que influye en el valor del elemento que queremos calcular, y lleva esa información al programa. \n\n4) Se puede completar el ejercicio comparando los dos primeros métodos en rangos mucho más amplios, y tratando de decidir si es verdad que el segundo siempre funciona mejor que el primero. "}
{"cell_type":"markdown","metadata":{},"source":"## Ejercicio 3 (3 puntos)\n\nFinalmente, estudiamos un **algoritmo para calcular factoriales** basado en el siguiente teorema:\n\n*Dados un entero $n$ y un primo $p\\le n$ el exponente de $p$ en la factorización de $n!$ en producto de primos es el entero $$exponente(p):=\\sum_{i=1}^{i=\\infty} floor(n/p^i).$$*\n\nObserva que la suma es en realidad finita, ya que en cuanto $p^i$ supera a $n$ los sumandos son todos cero, y para todos los primos $p\\le n$ el exponente correspondiente es al menos $1$. \n\n1) Define una función que reciba el entero $n$ como argumento y devuelva una lista de pares con el primer elemento de cada par uno de los primos $p\\le n$  y el segundo el exponente que corresponde a $p$ de acuerdo al teorema mencionado. \nPara generar la lista de primos menores o iguales a $n$ puedes usar la función de SAGE $prime\\_range$ o bien la función $criba$ del Ejercicio $1$. \n\n2) Define una función de nombre $factorial\\_n(n)$ que en primer lugar llame a la función del apartado anterior, y luego calcule el producto de todos los primos elevado cada uno a su exponente. El resultado debe ser el factorial de $n$. Para elevar cada primo a su exponente debería usarse el algoritmo recursivo, bastante eficiente,  visto en clase. \n\n3) **Ejecuta las celdas al final de este ejercicio para comprobar que la función definida es correcta.**\n\n4) **¿Se te ocurre alguna manera de mejorar la eficiencia de $factorial\\_n(n)$? Explica.**\n\n"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def primos(n):\n    L = []\n    L1 = prime_range(2,n+1)\n    for p in L1:\n        i = 1\n        suma = 0\n        while floor(n/(p**i))>=1:\n            suma += floor(n/(p**i))\n            i += 1\n        L.append((p,suma))\n    return L"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def potencia(a,k):\n    if k==0:\n        return 1\n    elif k %2 == 0:\n        b = potencia(a,k/2)\n        return (b*b)\n    else:\n        b = potencia(a,(k-1)/2)\n        return (a*b*b) "}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def factorial_n(n):\n    L = primos(n)\n    res = 1\n    for item in L:\n        res *= potencia(item[0],item[1])\n    return res"}
{"cell_type":"code","execution_count":8,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 220 ms, sys: 0 ns, total: 220 ms\nWall time: 219 ms\n"}],"source":"%time L1 = factorial(657975) ##Factorial de SAGE"}
{"cell_type":"code","execution_count":9,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 35.8 s, sys: 204 ms, total: 36 s\nWall time: 35.7 s\n"},{"data":{"text/plain":"True"},"execution_count":9,"metadata":{},"output_type":"execute_result"}],"source":"%time L1 == factorial_n(657975)"}
{"cell_type":"markdown","metadata":{"collapsed":true},"source":"1) Como alguien observó durante el examen, la función de SAGE $power(n,m)$ se puede utilizar en lugar de $potencia(n,m)$ y parece ser que es más eficiente.\n\n2) De acuerdo a la metodología explicada en clase, siguiendo las notas de Pablo Angulo, lo primero que habría  que hacer es *perfilar* el código para saber en qué partes conviene concentrarse, y sobre la parte que más tiempo consume tratar de cambiar el método de cálculo. Si esto no es posible, sólo quedaría intentar usar Cython y numpy, eliminando previamente todas las llamadas a funciones de Python o SAGE que teníamos. "}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":""}