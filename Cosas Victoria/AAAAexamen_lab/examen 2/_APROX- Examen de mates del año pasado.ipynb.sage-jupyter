{"kernelspec":{"display_name":"SageMath 7.5","language":"","name":"sagemath"},"language_info":{"codemirror_mode":{"name":"ipython","version":2},"file_extension":".py","mimetype":"text/x-python","name":"python","nbconvert_exporter":"python","pygments_lexer":"ipython2","version":"2.7.13"}}
{"cell_type":"markdown","metadata":{},"source":"Por favor, antes de empezar el examen cambia el nombre de la hoja (File>Rename worksheet) poniendo en lugar de \"nombre.apellido\" los tuyos tal como aparecen en tu dirección de correo electrónico de la UAM. El final del nombre de la hoja, -labot-ex2-2016, dejálo como está.\n\nUna vez hayas terminado el examen, salva la hoja (File>Save worksheet to a file....) y déjala en la carpeta en tu escritorio con nombre \"ENTREGA......\".\n\n### Ejercicio 1 ###\n\n (2 puntos) Define  funciones H(n,nbits) y H2(n,nbits) y que devuelvan la suma (sumatorio desde k= hasta k=n de 1/k) calculada con precisión igual a nbits. Las dos funciones serán esencialmente iguales,  pero H realizará todos los cálculos con números decimales de la precisión fijada mientras que H2 debe efectuar los cálculos con racionales,  y únicamente al devolver el resultado debe convertir a decimal de nbits de precisión. ¿Qué enseña este ejemplo?"}
{"cell_type":"code","execution_count":1,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def H(n,nbits):\n    R = RealField(prec=nbits)\n    S = R(0)\n    for j in xsrange(1,n+1):\n        S += R(1/j)\n    return S"}
{"cell_type":"code","execution_count":2,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"def H2(n,nbits):\n    R = RealField(prec=nbits)\n    S = 0\n    for j in xsrange(1,n+1):\n        S += 1/j\n    return R(S)"}
{"cell_type":"code","execution_count":3,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 664 ms, sys: 8 ms, total: 672 ms\nWall time: 735 ms\n"},{"data":{"text/plain":"13.699580042309"},"execution_count":3,"metadata":{},"output_type":"execute_result"}],"source":"time H(5*10^5, 50)"}
{"cell_type":"code","execution_count":4,"metadata":{"collapsed":false,"trusted":true},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 51.7 s, sys: 348 ms, total: 52 s\nWall time: 53 s\n"},{"data":{"text/plain":"13.699580042306"},"execution_count":4,"metadata":{},"output_type":"execute_result"}],"source":"time H2(5*10^5, 50)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"time H(26*10^6, 70)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"time H2(26*10^6, 70)"}
{"cell_type":"markdown","metadata":{},"source":"En este ejercicio se observa que el tiempo es mayor en la función de H2, ya que tiene que calcular la precision de un número mucho más complicado que no l de la funión de H que ca calclando la precisión de cada uno de los resultados, siendo este mucho más rápido"}
{"cell_type":"markdown","metadata":{},"source":"En muchos de los cálculos que nos interesan, en este capítulo 7,  sumamos términos de series de números racionales. Si efectuamos la suma como números racionales corremos el peligro de que las fracciones implicadas tengan numeradores y denominadores grandes,  lo que hace que el cálculo exacto con racionales sea muy costoso. Si lo que realmente nos interesa es el resultado final como decimal con un cierto número de bits de precisión  y no la fracción que determina ese decimal, este ejemplo muestra que nos conviene hacer todos los cálculos con decimales de la precisión fijada.\n"}
{"cell_type":"markdown","metadata":{},"source":"### Ejercicio 2 ###"}
{"cell_type":"markdown","metadata":{},"source":"Sabemos que la serie anterior es divergente. Además, sabemos que sus sumas parciales Hn tienen un valor no muy diferente\na log(n) (logaritmo neperiano siempre) ya que:\n\n    La integral entre 1 y x de 1/t dt es igual a log(x)\n    \ny Hn es una suma de Riemann de esta integral con los puntos de la partición con coordenadas enteras. Podemos entonces \ndecir que la serie diverge (aproximadamente) como el logaritmo.Euler definió la constante\n\n     cte de Euler := lim (Hn - log(n))\n                    n->00\ncuya existencia nos indica que la diferencia entre Hn y el logaritmo de n no crece con n . Sage dispone de un procedimiento, euler_gamma, para calcular con la precisión que queramos la constante de Euler.\n"}
{"cell_type":"markdown","metadata":{},"source":"#### 1)  Define una función mi_gamma1(n, nbits) que calcule el término n-ésimo de la sucesión que define gamma con nbits de precisión"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def mi_gamma1(n,nbits):\n    R = RealField(prec=nbits)\n    return -R(log(n))+H(n,nbits)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"time mi_gamma1(10^6,53)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"euler_gamma.n()"}
{"cell_type":"markdown","metadata":{},"source":"En este caso vemos que la precisión estándar de bits es suficiente para obtener cifras decimales correctas, y que no obtenemos más cifras correctas por aumentar la precisión."}
{"cell_type":"markdown","metadata":{},"source":"#### 2) Define una función mi_gamma2(n,nbits) que calcule el sumatorio desde 1 a n de 1/n*([n/k]-n/k)\n\nCon nbits de precisión. La notación [x] indica la parte entera por exceso de x. El límite, cuando n tiende a infinito, de (cte de Euler de n) se sabe que es (cte de Euler)."}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def F(n,nbits):\n    R = RealField(prec=nbits)\n    S = 0\n    for j in xsrange(1,n+1):\n        x = R(n/j)\n        S += ceil(x)-x\n    return S"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":true},"outputs":[],"source":"def mi_gamma2(n,nbits):\n    R = RealField(prec=nbits)\n    return R(F(n,nbits)/n)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"time mi_gamma2(10^6,53)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"time mi_gamma2(10^6, 106)"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":false,"trusted":true},"outputs":[],"source":"euler_gamma.n()\n"}
{"cell_type":"markdown","metadata":{},"source":"Vemos que el segundo método obtiene sólo 4 cifras decimales correctas y tarda más de cuatro veces más."}
{"cell_type":"markdown","metadata":{},"source":"#### 3) Define una función mi_gamma3(n,nbits) que calcule gamma sumando n términos de la serie\n    desde k=1 a k=n de (1/k-log(1+1/k))"}
{"cell_type":"code","execution_count":79,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def mi_gamma3(n,nbits):\n    R = RealField(prec=nbits)\n    S = 0\n    for j in xsrange(1, n+1):\n        x = R(1/j)\n        S += x-R(log(1+(1/j)))\n    return S\n    "}
{"cell_type":"code","execution_count":81,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 51.4 s, sys: 212 ms, total: 51.6 s\nWall time: 52.2 s\n"},{"data":{"text/plain":"0.577215164902028"},"execution_count":81,"metadata":{},"output_type":"execute_result"}],"source":"time mi_gamma3(10^6, 53)"}
{"cell_type":"code","execution_count":82,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 53.8 s, sys: 536 ms, total: 54.3 s\nWall time: 52.5 s\n"},{"data":{"text/plain":"0.5772151649019495269398456817487"},"execution_count":82,"metadata":{},"output_type":"execute_result"}],"source":"time mi_gamma3(10^6, 106)"}
{"cell_type":"code","execution_count":83,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"0.577215664901533"},"execution_count":83,"metadata":{},"output_type":"execute_result"}],"source":"euler_gamma.n()"}
{"cell_type":"markdown","metadata":{},"source":"Con el tercer método se recuperan 5 cifras correctas pero tarda más de 20 veces más que el primero."}
{"cell_type":"markdown","metadata":{},"source":"#### 4) Compara la cantidad de cifras correctas obtenidas y los tiempos de cálculo para los tres métodos,  usando 10^6 y  fijando la precisión óptima mediante experimentación. ¿Qué conclusiones obtienes y cuál puede ser el motivo?\n\n "}
{"cell_type":"markdown","metadata":{},"source":"Es bastante claro que el primer método es mejor que el segundo y éste mejor que el tercero. ¿Por qué?\nDebemos contar el número de operaciones que se hacen al aplicar cada uno de los métodos: En el primero calculamos n sumas y un logaritmo, en el segundo calculamos n divisiones y n sumas, y en el tercero n divisiones, n logaritmos y n sumas.\n"}
{"cell_type":"markdown","metadata":{},"source":"### Ejercicio 3\n\n(2 puntos) Se define la función phi(n) como la suma de todos los divisores positivos del entero positivo n. Sage dispone de la función sigma que realiza este cálculo. Determina (experimentalmente) el mayor entero positivo tal que la diferencia\n\n    e^(cte de euler) * n* log(log(n)) - phi(n)\n\nes negativa ( es la constante de Euler)."}
{"cell_type":"code","execution_count":84,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def FF(n,nbits):\n    R = RealField(prec=nbits)\n    return exp(R(euler_gamma))*n*R(log(log(n)))-sigma(n)\n"}
{"cell_type":"code","execution_count":85,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def mayor(N,nbits):\n    max = 1\n    for n in xsrange(1,N):\n        if FF(n,nbits)<0.0:\n            max = n\n    return max"}
{"cell_type":"code","execution_count":86,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 204 ms, sys: 4 ms, total: 208 ms\nWall time: 201 ms\n"},{"data":{"text/plain":"840"},"execution_count":86,"metadata":{},"output_type":"execute_result"}],"source":"time mayor(10^3,53)"}
{"cell_type":"code","execution_count":87,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 2.04 s, sys: 36 ms, total: 2.08 s\nWall time: 1.99 s\n"},{"data":{"text/plain":"5040"},"execution_count":87,"metadata":{},"output_type":"execute_result"}],"source":"time mayor(10^4,53)"}
{"cell_type":"code","execution_count":89,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 19.6 s, sys: 164 ms, total: 19.8 s\nWall time: 19.4 s\n"},{"data":{"text/plain":"5040"},"execution_count":89,"metadata":{},"output_type":"execute_result"}],"source":"time mayor(10^5,53)"}
{"cell_type":"markdown","metadata":{},"source":"Vemos que el entero buscado podría ser 5040 ya que no hay ninguno con FF(n,53) negativo entre 5041 y 10^5. Si quisiéramos comprobar hasta  10^6 debemos esperar que tarde del orden de 200 segundos, que no es demasiado. La precisión no parece ser importante en este problema, por lo que usamos la estándar de 53 bits."}
{"cell_type":"code","execution_count":90,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"L = [(n,FF(n,53)) for n in srange(2,10^4)]"}
{"cell_type":"code","execution_count":91,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"image/png":"smc-blob::e8a80be9-fe7d-472e-9b22-fda00a7405e8","text/plain":"Graphics object consisting of 1 graphics primitive"},"execution_count":91,"metadata":{},"output_type":"execute_result"}],"source":"points(L,pointsize=3)"}
{"cell_type":"markdown","metadata":{},"source":" No se sabe si es cierto que 5040 es el mayor entero tal que es negativo, pero esa afirmación se ha demostrado que es equivalente a la \"hipótesis de Riemann\"."}
{"cell_type":"markdown","metadata":{},"source":"### Ejercicio 4\n\nDefinimos una sucesión de números racionales mediante\n        G1=0, G2=1, Gn = Gn-1 + (1/n-2)*Gn-2 (n>=3)\n\n    (1 punto) Comprueba (experimentalmente)  que la fracción n/Gn tiende al número e.\n    (1 punto) Compara la eficiencia de esta manera de aproximar e con la de la forma,  más conocida,  que utiliza la serie\n            e= k=1 hasta k=00 de 1/n!\nProgramamos la recursión iterativamente, de forma similar a lo que hicimos para la sucesión de Fibonacci."}
{"cell_type":"code","execution_count":92,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"data":{"text/plain":"2.71828182845905"},"execution_count":92,"metadata":{},"output_type":"execute_result"}],"source":"def G(n):\n    a,b = 0,1\n    for j in xsrange(3,n):\n        b,a = b+(a/(j-2)),b\n    return b\n\nx = G(1000);RR(1000/x);RR(e)"}
{"cell_type":"code","execution_count":93,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def E(n,nbits):\n    R = RealField(prec=nbits)\n    a,b,k = R(0),R(1),3\n    while abs(R(k/b)-R(e))>R(10^(-n)):\n        b,a = R(b)+R(a/(k-2)),b\n        k += 1\n        #if k%10000 == 0:\n        #    print \"otros 10000\"  ##,k,abs(R(k/b)-R(e))\n    return R(k/b),R(k/b)-R(e),k"}
{"cell_type":"code","execution_count":94,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 56 ms, sys: 0 ns, total: 56 ms\nWall time: 52.6 ms\n"},{"data":{"text/plain":"(2.71928156432821, 0.000999735869168905, 2720)"},"execution_count":94,"metadata":{},"output_type":"execute_result"}],"source":"time E(3,53)"}
{"cell_type":"code","execution_count":95,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 23.8 s, sys: 248 ms, total: 24 s\nWall time: 23.8 s\n"},{"data":{"text/plain":"(2.71828282845870, 9.99999657302908e-7, 2718652)"},"execution_count":95,"metadata":{},"output_type":"execute_result"}],"source":"time E(6, 53)"}
{"cell_type":"code","execution_count":96,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":"def Eserie(n,nbits):\n    R = RealField(prec=nbits)\n    S,k =R(2),1\n    while abs(R(S)-R(e))>R(10^(-n)):\n        k += 1\n        S += R(1/factorial(k))\n    return R(S),R(S)-R(e),k"}
{"cell_type":"code","execution_count":97,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 0 ns, sys: 0 ns, total: 0 ns\nWall time: 474 µs\n"},{"data":{"text/plain":"(2.71828152557319, -3.02885852843104e-7, 9)"},"execution_count":97,"metadata":{},"output_type":"execute_result"}],"source":"time Eserie(6,53)"}
{"cell_type":"code","execution_count":98,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 0 ns, sys: 0 ns, total: 0 ns\nWall time: 286 µs\n"},{"data":{"text/plain":"(2.71828182845823, -8.14903700074865e-13, 14)"},"execution_count":98,"metadata":{},"output_type":"execute_result"}],"source":"time Eserie(12,53)\n"}
{"cell_type":"code","execution_count":99,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"ename":"KeyboardInterrupt","evalue":"","output_type":"error","traceback":["\u001b[1;31m---------------------------------------------------------------------------\u001b[0m","\u001b[1;31mKeyboardInterrupt\u001b[0m                         Traceback (most recent call last)","\u001b[1;32m<ipython-input-99-a842c8f0dec0>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n\u001b[1;32m----> 1\u001b[1;33m \u001b[0mget_ipython\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mmagic\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34mu'time Eserie(Integer(24),Integer(53))'\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m","\u001b[1;32m/usr/lib/sagemath/local/lib/python2.7/site-packages/IPython/core/interactiveshell.pyc\u001b[0m in \u001b[0;36mmagic\u001b[1;34m(self, arg_s)\u001b[0m\n\u001b[0;32m   2161\u001b[0m         \u001b[0mmagic_name\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0m_\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mmagic_arg_s\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0marg_s\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mpartition\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;34m' '\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2162\u001b[0m         \u001b[0mmagic_name\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mmagic_name\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mlstrip\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mprefilter\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mESC_MAGIC\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 2163\u001b[1;33m         \u001b[1;32mreturn\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mrun_line_magic\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mmagic_name\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mmagic_arg_s\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   2164\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2165\u001b[0m     \u001b[1;31m#-------------------------------------------------------------------------\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;32m/usr/lib/sagemath/local/lib/python2.7/site-packages/IPython/core/interactiveshell.pyc\u001b[0m in \u001b[0;36mrun_line_magic\u001b[1;34m(self, magic_name, line)\u001b[0m\n\u001b[0;32m   2082\u001b[0m                 \u001b[0mkwargs\u001b[0m\u001b[1;33m[\u001b[0m\u001b[1;34m'local_ns'\u001b[0m\u001b[1;33m]\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0msys\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0m_getframe\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mstack_depth\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mf_locals\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2083\u001b[0m             \u001b[1;32mwith\u001b[0m \u001b[0mself\u001b[0m\u001b[1;33m.\u001b[0m\u001b[0mbuiltin_trap\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 2084\u001b[1;33m                 \u001b[0mresult\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mfn\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0margs\u001b[0m\u001b[1;33m,\u001b[0m\u001b[1;33m**\u001b[0m\u001b[0mkwargs\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   2085\u001b[0m             \u001b[1;32mreturn\u001b[0m \u001b[0mresult\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   2086\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;32m<decorator-gen-60>\u001b[0m in \u001b[0;36mtime\u001b[1;34m(self, line, cell, local_ns)\u001b[0m\n","\u001b[1;32m/usr/lib/sagemath/local/lib/python2.7/site-packages/IPython/core/magic.pyc\u001b[0m in \u001b[0;36m<lambda>\u001b[1;34m(f, *a, **k)\u001b[0m\n\u001b[0;32m    191\u001b[0m     \u001b[1;31m# but it's overkill for just that one bit of state.\u001b[0m\u001b[1;33m\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    192\u001b[0m     \u001b[1;32mdef\u001b[0m \u001b[0mmagic_deco\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0marg\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m--> 193\u001b[1;33m         \u001b[0mcall\u001b[0m \u001b[1;33m=\u001b[0m \u001b[1;32mlambda\u001b[0m \u001b[0mf\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m*\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mk\u001b[0m\u001b[1;33m:\u001b[0m \u001b[0mf\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m*\u001b[0m\u001b[0ma\u001b[0m\u001b[1;33m,\u001b[0m \u001b[1;33m**\u001b[0m\u001b[0mk\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m    194\u001b[0m \u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m    195\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mcallable\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0marg\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;32m/usr/lib/sagemath/local/lib/python2.7/site-packages/IPython/core/magics/execution.pyc\u001b[0m in \u001b[0;36mtime\u001b[1;34m(self, line, cell, local_ns)\u001b[0m\n\u001b[0;32m   1171\u001b[0m         \u001b[1;32mif\u001b[0m \u001b[0mmode\u001b[0m\u001b[1;33m==\u001b[0m\u001b[1;34m'eval'\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1172\u001b[0m             \u001b[0mst\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mclock2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m-> 1173\u001b[1;33m             \u001b[0mout\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0meval\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mcode\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mglob\u001b[0m\u001b[1;33m,\u001b[0m \u001b[0mlocal_ns\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m   1174\u001b[0m             \u001b[0mend\u001b[0m \u001b[1;33m=\u001b[0m \u001b[0mclock2\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m   1175\u001b[0m         \u001b[1;32melse\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;32m<timed eval>\u001b[0m in \u001b[0;36m<module>\u001b[1;34m()\u001b[0m\n","\u001b[1;32m<ipython-input-96-c90c17fa13bb>\u001b[0m in \u001b[0;36mEserie\u001b[1;34m(n, nbits)\u001b[0m\n\u001b[0;32m      4\u001b[0m     \u001b[1;32mwhile\u001b[0m \u001b[0mabs\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mR\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mS\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m-\u001b[0m\u001b[0mR\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0me\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m>\u001b[0m\u001b[0mR\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m10\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m**\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;33m-\u001b[0m\u001b[0mn\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m:\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0;32m      5\u001b[0m         \u001b[0mk\u001b[0m \u001b[1;33m+=\u001b[0m \u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[1;32m----> 6\u001b[1;33m         \u001b[0mS\u001b[0m \u001b[1;33m+=\u001b[0m \u001b[0mR\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mInteger\u001b[0m\u001b[1;33m(\u001b[0m\u001b[1;36m1\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m/\u001b[0m\u001b[0mfactorial\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mk\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n\u001b[0m\u001b[0;32m      7\u001b[0m     \u001b[1;32mreturn\u001b[0m \u001b[0mR\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mS\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mR\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0mS\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m-\u001b[0m\u001b[0mR\u001b[0m\u001b[1;33m(\u001b[0m\u001b[0me\u001b[0m\u001b[1;33m)\u001b[0m\u001b[1;33m,\u001b[0m\u001b[0mk\u001b[0m\u001b[1;33m\u001b[0m\u001b[0m\n","\u001b[1;32msage/symbolic/function.pyx\u001b[0m in \u001b[0;36msage.symbolic.function.GinacFunction.__call__ (/usr/lib/sagemath//src/build/cythonized/sage/symbolic/function.cpp:9409)\u001b[1;34m()\u001b[0m\n","\u001b[1;32msage/symbolic/function.pyx\u001b[0m in \u001b[0;36msage.symbolic.function.BuiltinFunction.__call__ (/usr/lib/sagemath//src/build/cythonized/sage/symbolic/function.cpp:10839)\u001b[1;34m()\u001b[0m\n","\u001b[1;32msage/rings/integer.pyx\u001b[0m in \u001b[0;36msage.rings.integer.Integer.factorial (/usr/lib/sagemath//src/build/cythonized/sage/rings/integer.c:26544)\u001b[1;34m()\u001b[0m\n","\u001b[1;32msrc/cysignals/signals.pyx\u001b[0m in \u001b[0;36mcysignals.signals.sig_raise_exception (build/src/cysignals/signals.c:1125)\u001b[1;34m()\u001b[0m\n","\u001b[1;31mKeyboardInterrupt\u001b[0m: "]}],"source":"time Eserie(24,53)"}
{"cell_type":"code","execution_count":100,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 4 ms, sys: 0 ns, total: 4 ms\nWall time: 639 µs\n"},{"data":{"text/plain":"(2.718281828459045235360287404308, -6.704430225860226707718604610268e-26, 24)"},"execution_count":100,"metadata":{},"output_type":"execute_result"}],"source":"time Eserie(24,106)"}
{"cell_type":"markdown","metadata":{},"source":"No podemos calcular 24 cifras de e usando 53 bits de precisión, y el bucle en el primer caso es infinito. Doblando la precisión obtenemos más 4x24 =96 de bits de precisión, y el cálculo se realiza en menos de centésimas de segundo.  Es claro que la serie es un método mucho más eficiente, posiblemente debido a que\n\n    Como n! crece de forma tan bestial, los términos que sumamos son en seguida irrelevantes para alcanzar la precisión deseada.\n    Sage dispone de un método muy eficiente para calcular factoriales, de forma que algo que, en principio,  suena improbable, que se pueda calcular rápido el factorial de un número grande, de hecho es cierto.\n\nLas celdas que siguen calculan el número de cifras decimales de factoriales grandes y el tiempo de cálculo."}
{"cell_type":"code","execution_count":101,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 264 ms, sys: 0 ns, total: 264 ms\nWall time: 264 ms\n"},{"data":{"text/plain":"6984220"},"execution_count":101,"metadata":{},"output_type":"execute_result"}],"source":"time floor(log(factorial(1234567),base=10))"}
{"cell_type":"code","execution_count":102,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 4.45 s, sys: 0 ns, total: 4.45 s\nWall time: 4.45 s\n"},{"data":{"text/plain":"82187904"},"execution_count":102,"metadata":{},"output_type":"execute_result"}],"source":"time floor(log(factorial(12345678),base=10))"}
{"cell_type":"code","execution_count":103,"metadata":{"collapsed":false,"trusted":false},"outputs":[{"name":"stdout","output_type":"stream","text":"CPU times: user 1min 3s, sys: 496 ms, total: 1min 4s\nWall time: 1min 4s\n"},{"data":{"text/plain":"945335859"},"execution_count":103,"metadata":{},"output_type":"execute_result"}],"source":"time floor(log(factorial(123456789),base=10))"}
{"cell_type":"code","execution_count":null,"metadata":{"collapsed":true,"trusted":false},"outputs":[],"source":""}